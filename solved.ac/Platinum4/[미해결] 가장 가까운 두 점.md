# 가장 가까운 두 점

[백준 문제 링크](https://www.acmicpc.net/problem/2261)

**메모리 초과**로 실패했다. Y축으로 Sorting하는 과정에서 매번 새로운 Array가 생성되는게 문제가 아닐까 추측한다.

```javascript
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin", "utf8").trim().split("\n");

function getDistance(p1, p2) {
  return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2;
}

function lowerBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid][1] >= target) right = mid - 1;
    else left = mid + 1;
  }

  return left;
}

function upperBound(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid][1] > target) right = mid - 1;
    else left = mid + 1;
  }

  return right;
}

function initPoints() {
  const n = +input[0];
  const points = Array(n);

  for (let i = 0; i < n; i += 1) {
    points[i] = input[i + 1].split(" ").map((c) => +c);
  }

  return points.sort((a, b) => a[0] - b[0]);
}

function getMinFromCandidate(arr, start, ans, cur) {
  const sorted = arr.slice(start).sort((a, b) => a[1] - b[1]);

  const dist = Math.ceil(Math.sqrt(ans));
  const lower = lowerBound(sorted, cur[1] - dist);
  const upper = upperBound(sorted, cur[1] + dist);

  for (let i = lower; i <= upper; i += 1) {
    ans = Math.min(ans, getDistance(cur, sorted[i]));
  }

  return ans;
}

function solution() {
  const points = initPoints();
  const candidate = [points[0], points[1]];

  let candidateStart = 0;
  let ans = getDistance(points[0], points[1]);

  for (let i = 2; i < points.length; i += 1) {
    const cur = points[i];

    while (candidateStart < i) {
      const point = candidate[candidateStart];
      const x = cur[0] - point[0];
      if (x * x > ans) candidateStart += 1;
      else break;
    }

    ans = getMinFromCandidate(candidate, candidateStart, ans, cur);
    candidate.push(cur);
  }

  return ans;
}

console.log(solution());
```
