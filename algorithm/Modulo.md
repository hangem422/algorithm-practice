# 모듈로

## 1. 더하기

(A + B) mod M = ((A mod M) + (B mod M)) mod M

```javascript
const ans = ((A % M) + (B % M)) % M;
```

## 2. 빼기

(A - B) mod M = ((A mod M) - (B mod M)) mod M

```javascript
const ans = ((A % M) - (B % M)) % M;
```

## 3. 곱하기

(A \* B) mod M = ((A mod M) \* (B mod M)) mod M

```javascript
const ans = ((A % M) * (B % M)) % M;
```

## 4. 나누기

**페르소마 소정리:** B^M-1^ mod M = (B \* B^M-2^) mod M = 1, 단 M은 소수이고 B가 M의 배수가 아닌 경우

- (A / B) mod M
- (A \* B^-1^) mod M
- ((A mod M) \* (B^-1^ mod M)) mod M
- ((A mod M) \* (B^-1^ mod M) \* ((B \* B^M-2^) mod M )) mod M
- ((A mod M) \* ((B^-1^ \* B \* B^M-2^) mod M)) mod M
- ((A mod M) \* (B^M-2^ mod M)) mod M

```javascript
const ans = ((A % M) * (Math.pow(B, M - 2) % M)) % M;
```

## 5. Euler's phi

### 5.1 페르마 소정리와 오릴러 파이 함수의 관계

페르마 소정리는 오일러 정리에서 n이 소수인 특수한 경우입니다. 여기서 φ(n) 은 **오일러 파이 함수**(Euler Phi Function) 으로 불리는 함수로, 1부터 n 까지 n 과 서로소인 수들의 개수입니다. p가 소수라면 `φ(p) = p − 1`이 됩니다.

- **오일러 파이**: a^φ(n) mod n = 1 mod n
- **페르마 소정리**: a^p-1 mod p = 1 mod p

### 5.2 페르마 소정리 증명

p-1의 집합 `M = {1, 2, ... , p-1}`에서 모든 원소에 a를 곱한 `aM = {a, 2a, ... , a(p - 1)}`이 있을 때, `M = aM mod p`입니다. 예를 들어 `p = 5, a = 2`일 때, `M = {1, 2, 3, 4}`, `aM = {2, 4, 6, 8}`입니다. 이경우 `aM mod p = {2, 4, 1, 3} = {1, 2, 3, 4}`로 `M = aM mod p`입니다.

`M = {1, 2, ... , p - 1}`의 p - 1개 원소들은 모두 다르기 때문에 1에서 p의 수가 M에 전부 들어있습니다. 만약 `{a, 2a, ... , a(p - 1)} mod p`의 p - 1개 원소들도 서로 다르다면 `M = aM mod p`가 증명됩니다. 증명은 귀류법을 사용하면 간단합니다.

1. `i !== j`인데 `ai mod p = aj mod p`인 i, j가 존재한다고 가정합니다.
2. p가 소수이므로 양변을 a로 나눌 수 있습니다.
3. `i mod p = j mod p`가 되고, `1 <= i, j <= p - 1`인 조건에서는 `i = j`가 되므로 1번 가정은 모순입니다.
4. 따라서 `M = aM mod p`입니다.

두 집합이 법p에 대해 동일하므로 이 두 집합의 모든 각 원소를 곱한 값도 같을 것입니다.

1. 모듈로 곱하기 법칙에 의해서 `{1, 2, ... , p - 1}! mod p = {a, 2a, ... , a(p - 1)! mod p` 입니다.
2. `(1 * 2 * ... * (p - 1)) mod p = (a * 2a * ... * a(p - 1)) mod p`로 전개됩니다.
3. 결국 **(p - 1)! mod p = a^p-1^(p - 1)! mod p**이 성립합니다.
4. `(p − 1)!`과 `p`는 공통 인수를 가지지 않으므로 서로소입니다
5. `(p − 1)!`의 역원이 존재하며, 양변을 `(p − 1)!` 으로 나누면 **a^p-1^ mod p = 1 mod p**이 성립됩니다.

### 5.3 기약잉여계로 오일러 함수 증명

기약잉여계는 n과 서로소 n 이하의 정수로 이루어진 집합 M을 기약잉예계라 합니다. 위 페르마 정리를 인용하여 저리하면 다음과 같습니다.

1. M = {p~1~, p~1~, ... , p~φ(n)~}
2. aM = {ap~1~, ap~1~, ... , ap~φ(n)~}
3. M = aM mod n
4. M! mod n = a^φ(n)^M! mod n
5. a^φ(n)^ mod n = 1 mod n

### 5.4 오일러 파이 함수는 곱셈적 함수입니다.

오일러 파이 함수의 계산을 위한 가장 중요한 성질은 오일러 파이 함수가 곱셈적 함수 라는 성질입니다. 이는 다음을 의미합니다.

```
φ(m)φ(n) = φ(mn) (단, m,n은 서로소)
```

이 사실의 증명은 조금 더 복잡합니다. 먼저 다음과 같은 `m × n` 의 표를 보겠습니다.

|     |       |        |     |              |
| :-: | :---: | :----: | :-: | :----------: |
|  1  | m + 1 | 2m + 1 | ... | (n - 1)m + 1 |
|  2  | m + 2 | 2m + 2 | ... | (n - 1)m + 2 |
|  3  | m + 3 | 2m + 3 | ... | (n - 1)m + 3 |
| ... |  ...  |  ...   | ... |     ...      |
|  m  |  2m   |   3m   | ... |      nm      |

```
r행: r, m + r, 2m + r, ... , (n - 1)m + r
```

- **r과 m이 서로소인 경우**: r행, 즉 km + r 꼴의 모든 수는 m과 서로소가 아닙니다.
- **r과 m이 서로소인 경우**: r행, 즉 km + r 꼴의 모든 수는 m과 서로소입니다.

#### 5.4.1 r과 m이 서로소인 경우 증명

두 번째 케이스에 집중합니다. 두 번쨰 케이스의 경우, r행의 n개의 수들은 법 n에 대해 서로 다릅니다. 이는 귀류법으로 보일 수 있습니다.

1. `i !== j`인데 `(im + r) mod n = (jm + r) mod n`인 i, j가 존재한다고 가정합니다.
2. `im mod n = jm mod n`이 되고, m과 n은 서로소이므로 양변을 m으로 나눌 수 있습니다.
3. `i mod n = m mod n`이 되는데, i,j < n인 조건에서 `i = j`이 되므로 1번 가정은 모순입니다.

### 5.4.2 오일러 파이 함수 증명

r이 m과 서로소일 떄, r행의 원소들은 법 n에 대해 서로 다릅니다. 그런데 r행의 원소가 n개 존재하므로, r 행은 다음 집합과 합동입니다.

```
{r, m + r, 2m + r, ... , (n - 1)m + r} mod n = {0, 1, 2, ..., n - 1} mod n
```

0 부터 n - 1까지 모든 수가 빠짐없이 있으므로, 여기에는 n과 서로수인 φ(n)개의 수들도 빠짐없이 있을 것입니다. 그런데 애초에 r행은 모두 m과 서로소이므로 r행의 수 중 n과 서로소인 수는 mn과 서로소입니다. 한편 이런 행은 φ(m)개 존재합니다. 따라서 `φ(m)φ(n) = φ(mn)`이 됩니다.

### 오일러 파이 함수 계산

p가 소수라면 p^k^와 서로소가 아닌 수들은 반드시 p를 인수로 가져야 합니다. 1부터 p^k^까지의 수 중 이런 수들은 p^k^/p = p^k-1^개 있습니다. 따라서 **φ(p^k^) = p^k^ - p^k-1^** 이 결론으로부터 우리는 쉽게 오일러 파이 함수를 계산할 수 있습니다. 모든 수는 소수의 곱으로 나타낼 수 있으므로, 소인수분해를 한 뒤 오일러 파이 함수가 곱셈적 함수임을 이용해서 계산하면 됩니다.

- φ(a) = φ(p~1~^k1^p~2~^k2^...p~n~^kn^)
- φ(a) = φ(p~1~^k1^) φ(p~2~^k2^)... φ(p~n~^kn^)
- φ(a) = (p~1~^k1^ - p~1~^k1-1^)(p~2~^k2^ - p~2~^k2-2^)...(p~n~^kn^ - p~n~^kn-1^)
- φ(a) = p~1~^k1^(1 - 1 / p~1~)p~2~^k2^(1 - 1 /p~2~)....p~n~^kn^(1 - 1 / p~n~)
- φ(a) = p~1~^k1^p~2~^k2^...p~n~^kn^(1 - 1 / p~1~)(1 - 1 /p~2~)...(1 - 1 / p~n~)
- φ(a) = a(1 - 1 / p~1~)(1 - 1 /p~2~)...(1 - 1 / p~n~)
